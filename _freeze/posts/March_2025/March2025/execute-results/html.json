{
  "hash": "032b4c7c56e084a5ab578f52d303349a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"My Pain in R\"\nauthor: \"Nikita M.\"\ndate: \"2025-03-13\"\noutput:\n  html_document:\n    theme: flatly\n    highlight: tango\neditor: \n  markdown: \n    wrap: sentence\n---\n\n\n\n\n\n\n## Floating-Point Precision in R\n\nFloating-point numbers in R are subject to precision limitations due to [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) representation.\nThis section explores how seemingly simple operations can lead to unexpected results.\n\n### **Example 1: Floating-Point Comparison Fails**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.1 == .3 / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n**Why does this return `FALSE`?**\n\n-   Due to how floating-point arithmetic works in computers, numbers like `0.1`, `0.3`, and `0.3 / 3` are stored in binary.\n\n-   Some decimal fractions **cannot be represented exactly in binary**, leading to tiny rounding errors.\n\n-   Even though mathematically `.1` and `.3 / 3` should be the same, their internal representations **are not exactly equal**.\n\n### **Example 2: Inspecting the Actual Value Stored in Memory**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.3 / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(.3 / 3, digits=16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.09999999999999999\n```\n\n\n:::\n:::\n\n\n\n\n**Explanation:**\n\n-   The first output shows what R normally prints, which is rounded for display.\n\n-   The second output uses `digits=16` to show more of the **actual stored precision**.\n\n-   This reveals that `0.3 / 3` is actually stored as `0.09999999999999999`, **not exactly** `0.1`.\n\n### **Example 3: Using `all.equal()` Instead of `==`**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(.1, .3 / 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n**Why does this return `TRUE`?**\n\n-   `all.equal()` does not check for **exact** equality but allows a **small tolerance** to account for floating-point errors.\n\n-   It is the **preferred way** to compare floating-point numbers in R.\n\n### **Example 4: Machine Epsilon & Adjusting Tolerance**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.Machine$double.eps\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.220446e-16\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(.1, .3 / 3, tolerance = 2.2e-17)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mean relative difference: 1.387779e-16\"\n```\n\n\n:::\n:::\n\n\n\n\n**Explanation:**\n\n-   `.Machine$double.eps` is the smallest possible difference that R can distinguish between two floating-point numbers.\n\n-   The default tolerance of `all.equal()` is `sqrt(.Machine$double.eps)`, but we can **adjust it manually** if needed.\n\nðŸ“– **More details:** [The R Inferno](https://www.burns-stat.com/documents/books/the-r-inferno/)\n\n------------------------------------------------------------------------\n\n## Memory Allocation in R\n\nMemory management in R determines how objects are stored and how much space they occupy.\n**Understanding how R allocates memory** can help optimize performance, especially with large datasets.\n\n### **Example 5: Comparing Memory Usage of Integer and Double**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5    # Stored as double\nobj_size(x)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n56 B\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 5L   # Stored as integer\nobj_size(y) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n56 B\n```\n\n\n:::\n:::\n\n\n\n\n**Why are both `x` and `y` 56 bytes?**\n\n-   Even though `y` is an **integer (4 bytes)** and `x` is a **double (8 bytes)**, R adds metadata overhead.\n\n-   Every object in R carries around **48 bytes of metadata**, including type and reference count.\n\n-   Memory is aligned in **multiples of 8 bytes**, so the total allocation rounds up to 56 bytes.\n\n### **Example 6: Memory Usage for Large Vectors**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_vec <- rep(5, 1000000)   # Double vector\ny_vec <- rep(5L, 1000000)  # Integer vector\n\nobj_size(x_vec)  # ~8 MB (each number is 8 bytes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(y_vec)  # ~4 MB (each number is 4 bytes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4.00 MB\n```\n\n\n:::\n:::\n\n\n\n\n**Why does the integer vector use half the memory?**\n\n-   Each **integer** (`5L`) takes **4 bytes per element**.\n\n-   Each **double** (`5`) takes **8 bytes per element**.\n\n-   For **large datasets**, using integers instead of doubles can **save significant memory**.\n\n### **Example 7: Type Conversion Affects Memory Usage**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny_vec[2] = 5.0\nobj_size(y_vec)  # Changes due to type conversion\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nnew_vec = lapply(y_vec, as.integer)\nobj_size(new_vec) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n64.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nnew_vec[2] = 5.5\nnew_vec[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 5\n\n[[2]]\n[1] 5.5\n\n[[3]]\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(new_vec) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n64.00 MB\n```\n\n\n:::\n:::\n\n\n\n\n**Explanation:**\n\n-   Assigning `5.0` to `y_vec` **forces** R to convert the entire vector to **double**, increasing memory usage.\n\n-   `lapply(y_vec, as.integer)` converts the vector back to integers, reducing its size.\n\n-   But assigning `5.5` back **forces conversion to double again**.\n\n------------------------------------------------------------------------\n\n## Partial Matching in R\n\nR allows **partial matching** of list elements, which can lead to unintended behaviour and difficult-to-debug errors.\n\n### **Example 8: Partial Matching Works, But Itâ€™s Risky**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_function <- function(alpha = NULL, power = NULL, p = NULL, p0 = NULL) {\n  user_defined <- list(alpha=alpha, power=power, p=p, p0=p0)\n  user_defined <- Filter(Negate(is.null), user_defined)\n  return(user_defined)\n}\n\nresults = test_function(alpha=0.05, power=0.8)\nprint(str(results))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ alpha: num 0.05\n $ power: num 0.8\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(results$p)  # Partial matching\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in results$p: partial match of 'p' to 'power'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8\n```\n\n\n:::\n:::\n\n\n\n\n**Why is `results$p` returning `NULL`?**\n\n-   Because `p` was not provided in `test_function()`, but R still allows partial matching.\n\n### **Example 9: Unexpected Partial Matching in Lists**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = list(data = 2, power = 10)\nx$p  # Partial matching: returns 10\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in x$p: partial match of 'p' to 'power'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nif (x$p == 10) cat(\"variable p == 10\\n\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in x$p: partial match of 'p' to 'power'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nvariable p == 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# Avoiding partial matching\noptions(warnPartialMatchDollar = TRUE)\nprint(x$p)  # Now warns about partial matching\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in x$p: partial match of 'p' to 'power'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(x[[\"p\"]])  # Explicit retrieval, avoiding unexpected matches\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\n\n\n**Best Practices:**\n\n-   Use **`options(warnPartialMatchDollar = TRUE)`** to catch unintended partial matches.\n\n-   Always use **`x[[\"p\"]]`** instead of `x$p` to ensure explicit matching.\n\nðŸ“– **More details:** [Advanced R - Subsetting](https://adv-r.hadley.nz/subsetting.html?q=partial#section-1)\n\n------------------------------------------------------------------------\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}