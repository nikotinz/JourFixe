[
  {
    "objectID": "posts/March_2025/March2025.html",
    "href": "posts/March_2025/March2025.html",
    "title": "My Pain in R",
    "section": "",
    "text": "Floating-point numbers in R are subject to precision limitations due to IEEE 754 representation. This section explores how seemingly simple operations can lead to unexpected results.\n\n\n\n.1 == .3 / 3\n\n[1] FALSE\n\n\nWhy does this return FALSE?\n\nDue to how floating-point arithmetic works in computers, numbers like 0.1, 0.3, and 0.3 / 3 are stored in binary.\nSome decimal fractions cannot be represented exactly in binary, leading to tiny rounding errors.\nEven though mathematically .1 and .3 / 3 should be the same, their internal representations are not exactly equal.\n\n\n\n\n\n.3 / 3\n\n[1] 0.1\n\nprint(.3 / 3, digits=16)\n\n[1] 0.09999999999999999\n\n\nExplanation:\n\nThe first output shows what R normally prints, which is rounded for display.\nThe second output uses digits=16 to show more of the actual stored precision.\nThis reveals that 0.3 / 3 is actually stored as 0.09999999999999999, not exactly 0.1.\n\n\n\n\n\nall.equal(.1, .3 / 3)\n\n[1] TRUE\n\n\nWhy does this return TRUE?\n\nall.equal() does not check for exact equality but allows a small tolerance to account for floating-point errors.\nIt is the preferred way to compare floating-point numbers in R.\n\n\n\n\n\n.Machine$double.eps\n\n[1] 2.220446e-16\n\nall.equal(.1, .3 / 3, tolerance = 2.2e-17)\n\n[1] \"Mean relative difference: 1.387779e-16\"\n\n\nExplanation:\n\n.Machine$double.eps is the smallest possible difference that R can distinguish between two floating-point numbers.\nThe default tolerance of all.equal() is sqrt(.Machine$double.eps), but we can adjust it manually if needed.\n\nüìñ More details: The R Inferno"
  },
  {
    "objectID": "posts/March_2025/March2025.html#floating-point-precision-in-r",
    "href": "posts/March_2025/March2025.html#floating-point-precision-in-r",
    "title": "My Pain in R",
    "section": "",
    "text": "Floating-point numbers in R are subject to precision limitations due to IEEE 754 representation. This section explores how seemingly simple operations can lead to unexpected results.\n\n\n\n.1 == .3 / 3\n\n[1] FALSE\n\n\nWhy does this return FALSE?\n\nDue to how floating-point arithmetic works in computers, numbers like 0.1, 0.3, and 0.3 / 3 are stored in binary.\nSome decimal fractions cannot be represented exactly in binary, leading to tiny rounding errors.\nEven though mathematically .1 and .3 / 3 should be the same, their internal representations are not exactly equal.\n\n\n\n\n\n.3 / 3\n\n[1] 0.1\n\nprint(.3 / 3, digits=16)\n\n[1] 0.09999999999999999\n\n\nExplanation:\n\nThe first output shows what R normally prints, which is rounded for display.\nThe second output uses digits=16 to show more of the actual stored precision.\nThis reveals that 0.3 / 3 is actually stored as 0.09999999999999999, not exactly 0.1.\n\n\n\n\n\nall.equal(.1, .3 / 3)\n\n[1] TRUE\n\n\nWhy does this return TRUE?\n\nall.equal() does not check for exact equality but allows a small tolerance to account for floating-point errors.\nIt is the preferred way to compare floating-point numbers in R.\n\n\n\n\n\n.Machine$double.eps\n\n[1] 2.220446e-16\n\nall.equal(.1, .3 / 3, tolerance = 2.2e-17)\n\n[1] \"Mean relative difference: 1.387779e-16\"\n\n\nExplanation:\n\n.Machine$double.eps is the smallest possible difference that R can distinguish between two floating-point numbers.\nThe default tolerance of all.equal() is sqrt(.Machine$double.eps), but we can adjust it manually if needed.\n\nüìñ More details: The R Inferno"
  },
  {
    "objectID": "posts/March_2025/March2025.html#memory-allocation-in-r",
    "href": "posts/March_2025/March2025.html#memory-allocation-in-r",
    "title": "My Pain in R",
    "section": "Memory Allocation in R",
    "text": "Memory Allocation in R\nMemory management in R determines how objects are stored and how much space they occupy. Understanding how R allocates memory can help optimize performance, especially with large datasets.\n\nExample 5: Comparing Memory Usage of Integer and Double\n\nx &lt;- 5    # Stored as double\nobj_size(x)  \n\n56 B\n\n\n\ny &lt;- 5L   # Stored as integer\nobj_size(y) \n\n56 B\n\n\nWhy are both x and y 56 bytes?\n\nEven though y is an integer (4 bytes) and x is a double (8 bytes), R adds metadata overhead.\nEvery object in R carries around 48 bytes of metadata, including type and reference count.\nMemory is aligned in multiples of 8 bytes, so the total allocation rounds up to 56 bytes.\n\n\n\nExample 6: Memory Usage for Large Vectors\n\nx_vec &lt;- rep(5, 1000000)   # Double vector\ny_vec &lt;- rep(5L, 1000000)  # Integer vector\n\nobj_size(x_vec)  # ~8 MB (each number is 8 bytes)\n\n8.00 MB\n\nobj_size(y_vec)  # ~4 MB (each number is 4 bytes)\n\n4.00 MB\n\n\nWhy does the integer vector use half the memory?\n\nEach integer (5L) takes 4 bytes per element.\nEach double (5) takes 8 bytes per element.\nFor large datasets, using integers instead of doubles can save significant memory.\n\n\n\nExample 7: Type Conversion Affects Memory Usage\n\ny_vec[2] = 5.0\nobj_size(y_vec)  # Changes due to type conversion\n\n8.00 MB\n\nnew_vec = lapply(y_vec, as.integer)\nobj_size(new_vec) \n\n64.00 MB\n\nnew_vec[2] = 5.5\nnew_vec[1:3]\n\n[[1]]\n[1] 5\n\n[[2]]\n[1] 5.5\n\n[[3]]\n[1] 5\n\nobj_size(new_vec) \n\n64.00 MB\n\n\nExplanation:\n\nAssigning 5.0 to y_vec forces R to convert the entire vector to double, increasing memory usage.\nlapply(y_vec, as.integer) converts the vector back to integers, reducing its size.\nBut assigning 5.5 back forces conversion to double again."
  },
  {
    "objectID": "posts/March_2025/March2025.html#partial-matching-in-r",
    "href": "posts/March_2025/March2025.html#partial-matching-in-r",
    "title": "My Pain in R",
    "section": "Partial Matching in R",
    "text": "Partial Matching in R\nR allows partial matching of list elements, which can lead to unintended behaviour and difficult-to-debug errors.\n\nExample 8: Partial Matching Works, But It‚Äôs Risky\n\ntest_function &lt;- function(alpha = NULL, power = NULL, p = NULL, p0 = NULL) {\n  user_defined &lt;- list(alpha=alpha, power=power, p=p, p0=p0)\n  user_defined &lt;- Filter(Negate(is.null), user_defined)\n  return(user_defined)\n}\n\nresults = test_function(alpha=0.05, power=0.8)\nprint(str(results))\n\nList of 2\n $ alpha: num 0.05\n $ power: num 0.8\nNULL\n\nprint(results$p)  # Partial matching\n\nWarning in results$p: partial match of 'p' to 'power'\n\n\n[1] 0.8\n\n\nWhy is results$p returning NULL?\n\nBecause p was not provided in test_function(), but R still allows partial matching.\n\n\n\nExample 9: Unexpected Partial Matching in Lists\n\nx = list(data = 2, power = 10)\nx$p  # Partial matching: returns 10\n\nWarning in x$p: partial match of 'p' to 'power'\n\n\n[1] 10\n\nif (x$p == 10) cat(\"variable p == 10\\n\")\n\nWarning in x$p: partial match of 'p' to 'power'\n\n\nvariable p == 10\n\n# Avoiding partial matching\noptions(warnPartialMatchDollar = TRUE)\nprint(x$p)  # Now warns about partial matching\n\nWarning in x$p: partial match of 'p' to 'power'\n\n\n[1] 10\n\nprint(x[[\"p\"]])  # Explicit retrieval, avoiding unexpected matches\n\nNULL\n\n\nBest Practices:\n\nUse options(warnPartialMatchDollar = TRUE) to catch unintended partial matches.\nAlways use x[[\"p\"]] instead of x$p to ensure explicit matching.\n\nüìñ More details: Advanced R - Subsetting"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is a website of recurring quarterly meeting series dedicated to fostering discussions on R programming, data science, and statistical computing within our research unit.\nEach session features hands-on demonstrations, deep dives into technical topics, and collaborative problem-solving, ensuring both theoretical depth and practical applicability."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for a Jour Fixe",
    "section": "",
    "text": "–û–±—â–∏–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏ –º–µ–∂—Å—Ç—Ä–∞–Ω–æ–≤–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è\n\n\n\n\n\n\nR-tips\n\n\n\n\n\n\n\n\n\nMar 13, 2025\n\n\nNikita M.\n\n\n\n\n\n\nNo matching items"
  }
]